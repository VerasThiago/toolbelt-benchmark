"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_error_report_1 = require("@vtex/node-error-report");
const __1 = require("..");
const LogFields_1 = require("../LogFields");
const utils_1 = require("../utils");
class ErrorReport extends node_error_report_1.ErrorReportBase {
    static create(args) {
        return new ErrorReport(node_error_report_1.createErrorReportBaseArgs(args));
    }
    injectOnSpan(span, logger) {
        var _a;
        span.setTag(__1.TracingTags.ERROR, 'true');
        const indexedLogs = {
            [LogFields_1.LOG_FIELDS.ERROR_KIND]: this.kind,
            [LogFields_1.LOG_FIELDS.ERROR_ID]: this.metadata.errorId,
        };
        if (node_error_report_1.isRequestInfo(this.parsedInfo) &&
            this.parsedInfo.response &&
            node_error_report_1.isInfraErrorData((_a = this.parsedInfo.response) === null || _a === void 0 ? void 0 : _a.data)) {
            indexedLogs[LogFields_1.LOG_FIELDS.ERROR_SERVER_CODE] = this.parsedInfo.response.data.code;
            indexedLogs[LogFields_1.LOG_FIELDS.ERROR_SERVER_REQUEST_ID] = this.parsedInfo.response.data.requestId;
        }
        const serializableError = this.toObject();
        span.log({ [LogFields_1.LOG_FIELDS.EVENT]: 'error', ...indexedLogs, error: serializableError });
        if (logger && this.shouldLogToSplunk(span)) {
            logger.error(serializableError);
            this.markErrorAsReported();
        }
        return this;
    }
    shouldLogToSplunk(span) {
        return !this.isErrorReported() && utils_1.getTraceInfo(span).isSampled;
    }
}
exports.ErrorReport = ErrorReport;
